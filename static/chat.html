  <!doctype html>
  <html lang="zh-Hant">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>æ—…éŠåŠ©æ‰‹ â€” äº’å‹•è¦åŠƒ</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="style.css">
    <style>
      :root{
        --bg-1: #fff6f3; /* soft cream */
        --card-bg: #ffffff;
        --accent: #2463ff; /* blue accent */
        --muted: #f3ece8;
        --llm-text: #0f172a;
        --user-text: #003826;
      }

      html, body { height:100%; }
      body{ background: linear-gradient(180deg,var(--bg-1),#fffaf8); font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial; overflow:hidden; }

      /* Full-bleed chat card: remove side margins so the card stretches to viewport edges */
      .chat-container{ width:100%; max-width:none; margin:0; padding:0; border-radius:0; }
      .chat-area{ min-height:68vh; }

      /* Main chat pane (single column) â€” larger and centered left-to-right with roomy right side */
      /* full-bleed pane: let the pane span full width, keep inner padding as gutters */
      .llm-pane{ background: var(--card-bg); border-radius:0; padding:2rem 1.25rem 2rem 2rem; box-shadow:none; overflow:auto; max-height: calc(100vh - 180px); box-sizing:border-box; width:100%; }

      /* Message bubbles */
      .msg{ margin-bottom:1.25rem; display:flex; }
      .bubble{ background:transparent; border-radius:14px; padding:0.9rem 1.05rem; max-width:78%; white-space:pre-wrap; word-break:break-word; line-height:1.7; font-size:1.03rem; }
      .msg.llm{ justify-content:flex-start; }
      .msg.llm .bubble{ background: linear-gradient(180deg,var(--card-bg),#fbfdff); color:var(--llm-text); box-shadow:0 6px 18px rgba(2,6,23,.04); }
      .msg.user{ justify-content:flex-end; }
      .msg.user .bubble{ background: linear-gradient(90deg,#e6fff2,#c8f2d9); color:var(--user-text); box-shadow:0 6px 18px rgba(2,6,23,.04); }
      .msg.user .bubble{ display:inline-block; margin-left:12px; }

      /* remove extra side gutters for full-bleed; keep small padding on very wide screens if desired */
      @media (min-width:1400px){ .llm-pane{ padding-left:4rem; padding-right:2.5rem; } }

      /* Input area styling and accent button */
      .chat-input-bar{ margin-top:1.25rem; display:flex; gap:0.75rem; align-items:center; }
      .chat-input-bar .form-control{ border-radius:14px; padding:1rem 1rem; box-shadow:0 6px 18px rgba(2,6,23,.03) inset; }
      .chat-input-bar .btn{ background:var(--accent); border:none; color:#fff; padding:0.7rem 0.9rem; border-radius:12px; box-shadow:0 8px 20px rgba(36,99,255,0.18); }

      /* small screens behavior */
      @media (max-width:992px){ .chat-container{ max-width:95%; padding-left:16px; padding-right:16px; } .bubble{ max-width:92%; } }

      /* Attraction card layout: numbered title, then image + description */
      .attraction{ margin:0.6rem 0; }
      .attraction-item{ margin-bottom:0.75rem; border-radius:10px; padding:0.6rem; background:linear-gradient(180deg,#ffffff,#fbfbfd); box-shadow:0 6px 18px rgba(2,6,23,.03); }
      .attraction-title{ font-weight:600; margin-bottom:0.45rem; color:var(--accent); }
      .attraction-body{ display:flex; gap:0.75rem; align-items:flex-start; }
      .attraction-item .images{ flex:0 0 400px; max-width:400px; }
      .attraction-item .images img{ width:100%; height:300px; object-fit:cover; border-radius:8px; display:block; }
      .attraction .meta{ flex:1 1 auto; color:var(--llm-text); font-size:0.98rem; line-height:1.55; }
      .img-link code{ display:inline-block; margin-left:8px; font-family:monospace; font-size:0.82rem; color:#4b5563; }
    </style>
  </head>
  <body>
    <nav class="navbar navbar-expand-lg mb-3" style="background:linear-gradient(90deg,#ffffff,#fdebd0);">
      <div class="container">
        <a class="navbar-brand" href="/web/">æ—…éŠåŠ©æ‰‹</a>
        <div class="ms-auto">
          <button id="backBtn" class="btn btn-outline-secondary btn-sm">å›åˆ—è¡¨</button>
        </div>
      </div>
    </nav>

    <main class="container-fluid">
      <div class="chat-container shadow-sm rounded-3 p-3">
        <div class="row g-0">
          <div class="col-12 chat-area">
            <div id="llmPane" class="llm-pane p-3">
              <!-- LLM messages (left) -->
            </div>
          </div>
          <!-- right column removed: user messages will appear inside the main llmPane as right-aligned bubbles -->
        </div>

        <div class="chat-input-bar mt-3 d-flex gap-2">
          <input id="chatInput" class="form-control" placeholder="è¼¸å…¥ä½ çš„å•é¡Œæˆ–æŒ‡ç¤ºï¼ˆä¾‹å¦‚ï¼šå¹«æˆ‘èª¿æ•´è¡Œç¨‹ï¼‰" />
          <button id="sendBtn" class="btn btn-primary">ğŸ’¬</button>
        </div>
        <!-- Instant display: messages revealed immediately (no typing) -->
      </div>
    </main>

    <script>
      // ====== 1. åŸºç¤è¨­å®š ======
      const API = '/api';
      // Toggle for testing: when true, frontend will use local images under /web/Source_img
      // instead of calling the Unsplash API. Set to false to use Unsplash via backend.
      const USE_LOCAL_IMAGES = false;

      const params = new URLSearchParams(location.search);
      const rawId = params.get('trip') || params.get('tripId');
      // å¦‚æœæ²’æœ‰ IDï¼Œå°±è¨­ç‚º null
      const tripId = (rawId && rawId !== 'undefined' && rawId !== 'null') ? rawId : null;
      const STORAGE_KEY = `chat_history_${tripId}`;
      let chatHistory = []; 

      document.getElementById('backBtn').addEventListener('click', () => {
        if (tripId) {
          // from=chat åªæ˜¯æ¨™è¨˜ä¸€ä¸‹æ˜¯å¾èŠå¤©é å›ä¾†
          location.href = `/web/?trip=${encodeURIComponent(tripId)}&from=chat`;
        } else {
          location.href = '/web/';
        }
      });

      const llmPane = document.getElementById('llmPane');
      const input = document.getElementById('chatInput');
      const sendBtn = document.getElementById('sendBtn');

      // ====== 2. UI æ¸²æŸ“å·¥å…· ======
      function escapeHtml(s){ return String(s).replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;"); }

      function formatMessageToHtml(text){
        if(!text) return '';
        // basic escapes and markdown-like transforms
        let raw = String(text);
        raw = raw.replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>');
        raw = raw.replace(/### (.*)/g, '<h4>$1</h4>'); // æ¨™é¡Œ

        const lines = raw.split('\n');
        const parts = [];
        for (let ln of lines) {
          const line = ln.trim();
          // remove HTML tags for matching purposes (backend may already include <strong>...)
          const plainLine = ln.replace(/<[^>]+>/g, '').trim();
          // remove leading bullets/numbers (e.g. "â€¢ ", "1.") to help matching
          const normalized = plainLine.replace(/^[\s\u2022\-\d\.\)]+/, '').trim();
          // debug: log the normalized line so we can inspect what the model returned
          console.debug('plainLine/normalized:', JSON.stringify(plainLine), '=>', JSON.stringify(normalized));
          // detect attraction lines like "æ™¯é»ï¼šå°åŒ—è»Šç«™ã€å£«æ—å¤œå¸‚" even if wrapped in tags or prefixed
          const attrMatch = normalized.match(/(?:æ™¯é»|åœ°é»|Attraction)[:ï¼š]\s*(.+)$/i);
          if (attrMatch) {
              const namesStr = attrMatch[1];
              // keep parenthetical content together: remove internal delimiters/newlines inside parentheses
              let cleaned = namesStr.replace(/ï¼ˆ[^ï¼‰]*ï¼‰/g, m => m.replace(/[ã€,;ï¼›\/\n]+/g, ' '));
              cleaned = cleaned.replace(/\([^\)]*\)/g, m => m.replace(/[ã€,;ï¼›\/\n]+/g, ' '));
              cleaned = cleaned.replace(/\s+/g,' ').trim();
              const names = cleaned.split(/[ã€,;ï¼›\/\n]+/).map(s=>s.trim()).filter(Boolean);
            const itemsHtml = names.map((n, idx) => {
              // sanitize name for query: remove parenthetical, alternatives, slashes
              let qname = String(n).replace(/\s*\(.*$/,'').replace(/\s*ï¼ˆ.*$/,'').replace(/\s*æˆ–.*$/,'').replace(/\s*\/.*$/,'').trim();
              if (!qname) qname = n;
              const q = encodeURIComponent(qname.replace(/\s+/g,' '));
              // placeholder 1x1 gif until backend returns an Unsplash URL
              const placeholder = 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///ywAAAAAAQABAAACAUwAOw==';
              const titleHtml = escapeHtml(n);
              const descHtml = escapeHtml(namesStr);
              return `<div class="attraction-item">`+
                       `<div class="attraction-title">${idx+1}. ${titleHtml}</div>`+
                       `<div class="attraction-body">`+
                         `<div class="images"><img data-query="${q}" src="${placeholder}" alt="${escapeHtml(n)}" loading="lazy"></div>`+
                        `<div class="meta"><div class="desc">${descHtml}</div>`+
                          `<div class="img-link" style="margin-top:8px;font-size:0.85rem;color:#6b6b6b;">`+
                            `<a class="view-img" href="#" data-query="${q}">æŸ¥çœ‹åœ–ç‰‡</a>`+
                            `<code data-url></code>`+
                          `</div>`+
                        `</div>`+
                       `</div>`+
                     `</div>`;
            }).join('');
            console.log('attraction detected:', names, 'generated srcs:', names.map(n=>`https://source.unsplash.com/800x600/?${encodeURIComponent(n.replace(/\s+/g,' '))}`));
            parts.push(itemsHtml);
            continue;
          }

          // bullet conversion for lines starting with '* '
          const bullet = plainLine.match(/^\*\s+(.*)$/);
          const hasHtml = /<[^>]+>/.test(ln);
          if (bullet) {
            const content = bullet[1];
            parts.push('â€¢ ' + (hasHtml ? ln.replace(/^[\s\S]*?\*\s*/,'') : escapeHtml(content)));
          } else {
            parts.push(hasHtml ? ln : escapeHtml(line));
          }
        }

        return parts.join('<br>');
      }
      
      function createBubble(role, text) {
          const el = document.createElement('div'); 
          el.className = `msg ${role} mb-3`;
          const bubble = document.createElement('div'); 
          bubble.className = `bubble ${role==='user'?'user-bubble d-inline-block':''}`;
          bubble.innerHTML = formatMessageToHtml(text);
          el.appendChild(bubble);
          llmPane.appendChild(el);
          llmPane.scrollTop = llmPane.scrollHeight;
          // after inserting, try to load unsplash images for any placeholders
          try { loadUnsplashImages(el); } catch(e){ /* ignore */ }
          return bubble;
      }
      
      // ç”¨ä¾†æ›´æ–°æ³¡æ³¡å…§å®¹ (ä¾‹å¦‚å¾ "æ€è€ƒä¸­" è®Šæˆ "çµæœ")
      function displayText(bubble, text) { 
          bubble.innerHTML = formatMessageToHtml(text); 
          llmPane.scrollTop = llmPane.scrollHeight; 
          try { loadUnsplashImages(bubble.parentElement); } catch(e) { console.error(e); }
      }
      
      function saveHistory() { 
          if(tripId) localStorage.setItem(STORAGE_KEY, JSON.stringify(chatHistory)); 
      }

      // Fetch Unsplash URL from backend and update <img> placeholders
      async function loadUnsplashImages(container){
        const imgs = Array.from(container.querySelectorAll('img[data-query]'));
        const tasks = imgs.map(async (img) => {
          const q = decodeURIComponent(img.getAttribute('data-query') || '');
          if(!q) return;
          try{
            if (USE_LOCAL_IMAGES) {
              const local = "Source_img/image1.jpg";
              if (local) {
                img.src = local;
                const parent = img.closest('.attraction-item');
                if(parent){
                  const a = parent.querySelector('a.view-img');
                  const code = parent.querySelector('code[data-url]');
                  if(a){ a.href = local; a.target = '_blank'; a.rel='noopener noreferrer'; }
                  if(code){ code.textContent = local; }
                }
                return;
              }
            }

            const res = await fetch(`/api/unsplash?query=${encodeURIComponent(q)}`);
            if(!res.ok) return;
            const j = await res.json();
            if(j && j.url){
              img.src = j.url;
              // update link and code text
              const parent = img.closest('.attraction-item');
              if(parent){
                const a = parent.querySelector('a.view-img');
                const code = parent.querySelector('code[data-url]');
                if(a){ a.href = j.url; a.target = '_blank'; a.rel='noopener noreferrer'; }
                if(code){ code.textContent = j.url; }
              }
            }
          }catch(e){ console.error('unsplash fetch error', e); }
        });
        await Promise.all(tasks);
      }

      // ========== ä¿®æ­£å¾Œçš„ sendMessage ==========
      async function sendMessage(text, isAutoTrigger = false) {
        if (!text) return;

        if (!isAutoTrigger) {
          createBubble('user', text);
        }

        chatHistory.push({ role: 'user', text });
        saveHistory();

        const loadingBubble = createBubble('llm', 'ï¼ˆæ­£åœ¨æ€è€ƒèˆ‡è¦åŠƒ...ï¼‰');

        try {
          const res = await fetch(`${API}/gemini/chat`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ message: text, history: chatHistory })
          });

          if (!res.ok) {
            let errorMsg = 'API Error ' + res.status;
            try {
              const errData = await res.json();
              if (errData && errData.error) {
                errorMsg = errData.error;
              }
            } catch (_ignore) {
              // å¾Œç«¯ä¸æ˜¯ JSONï¼Œå°±ç¶­æŒåŸæœ¬çš„ errorMsg
            }
            throw new Error(errorMsg);
          }

          const data = await res.json();
          const reply = (data && data.reply) ? data.reply : '(ç„¡å›æ‡‰)';

          displayText(loadingBubble, reply);
          chatHistory.push({ role: 'model', text: reply });
          saveHistory();

        } catch (e) {
          console.error(e);
          const msg = e && e.message ? e.message : String(e);
          displayText(loadingBubble, 'ç™¼ç”ŸéŒ¯èª¤ï¼š' + msg);
        }
      }


      // ====== 4. åˆå§‹åŒ– (é€²ä¾†é é¢æ™‚åŸ·è¡Œ) ======
      async function initChat() {
          if (!tripId) {
              createBubble('llm', "ğŸ‘‹ ä½ å¥½ï¼ç¶²å€ä¼¼ä¹ç¼ºå°‘è¡Œç¨‹ IDã€‚<br>è«‹å›åˆ°ä¸Šä¸€é é‡æ–°å»ºç«‹è¡Œç¨‹ã€‚");
              return;
          }

          const saved = localStorage.getItem(STORAGE_KEY);

          if (saved) {
              // A. æœ‰èˆŠç´€éŒ„ï¼šè¼‰å…¥ä¸¦é¡¯ç¤º
              try {
                  chatHistory = JSON.parse(saved);
                  if(chatHistory.length > 0) {
                      chatHistory.forEach(msg => {
                          // éæ¿¾æ‰ç³»çµ±æŒ‡ä»¤ï¼Œåªé¡¯ç¤ºæ­£å¸¸çš„å°è©±
                          if (!msg.text.startsWith('SYSTEM_prompt:')) {
                              createBubble(msg.role, msg.text);
                          }
                      });
                      // å¦‚æœè¼‰å…¥å®Œæ²’æ±è¥¿ (ä¾‹å¦‚åªæœ‰éš±è—æŒ‡ä»¤)ï¼Œè£œå€‹æ­¡è¿è©
                      // if(llmPane.children.length === 0) createBubble('llm', "æ­¡è¿å›ä¾†ï¼");
                  } else {
                      // æœ‰ key ä½†å…§å®¹æ˜¯ç©ºé™£åˆ—
                      startNewPlanning();
                  }
              } catch(e) {
                  console.error("History parse error", e);
                  startNewPlanning();
              }
          } else {
              // B. ç„¡ç´€éŒ„ï¼šé–‹å§‹æ–°è¦åŠƒ
              startNewPlanning();
          }
      }

      // é–‹å§‹å…¨æ–°çš„è¦åŠƒæµç¨‹
        async function startNewPlanning() {
          const bubble = createBubble('llm', "æ­£åœ¨è®€å–æ‚¨çš„è¡Œç¨‹è¨­å®š...");
          
          try {
            // 1. å»è³‡æ–™åº«æŠ“ä½¿ç”¨è€…çš„è¨­å®š (index.html å­˜çš„é‚£ä»½)
            const res = await fetch(`${API}/trips/${tripId}`);
            if (res.ok) {
              const tripData = await res.json();
                  
              // æ›´æ–°æ³¡æ³¡æ–‡å­—
              displayText(bubble, `å—¨ï¼æˆ‘çœ‹åˆ°æ‚¨æƒ³å» **${tripData.region}** ç© ${tripData.days} å¤©ã€‚\næˆ‘æ­£åœ¨æ ¹æ“šæ‚¨çš„åå¥½ï¼ˆ${tripData.preferences?.pace || 'é©ä¸­'}ã€${tripData.preferences?.types?.join('/') || 'ç„¡'}ï¼‰ç‚ºæ‚¨è¦åŠƒ...`);
                  
              // 2. çµ„è£æŒ‡ä»¤çµ¦ AI (é€™æ®µä½¿ç”¨è€…çœ‹ä¸åˆ°)
              const prompt = `SYSTEM_prompt: è«‹æ‰®æ¼”å°ˆæ¥­å°éŠã€‚\n  é€™æ˜¯ä½¿ç”¨è€…çš„è¡Œç¨‹éœ€æ±‚ JSONï¼š${JSON.stringify(tripData)}\n  è«‹æ ¹æ“šæ­¤è³‡è¨Šï¼Œè¦åŠƒä¸€ä»½è©³ç´°çš„${tripData.days}å¤©è¡Œç¨‹ã€‚\n  è«‹ç”¨ç¹é«”ä¸­æ–‡ï¼Œæ¢åˆ—å¼å‘ˆç¾ï¼ŒåŒ…å«æ¯å¤©çš„æ™¯é»ã€é¤é£²å»ºè­°ï¼Œæ™¯é»æ¬„ä½è¦æ˜¯è‹±æ–‡å\n  è«‹ç›´æ¥é–‹å§‹è¦åŠƒï¼Œä¸ç”¨è§£é‡‹.`;
              
                  
              // 3. è‡ªå‹•ç™¼é€
              await sendMessage(prompt, true);
                  
            } else {
              displayText(bubble, `æ‰¾ä¸åˆ°è¡Œç¨‹è³‡æ–™ (ID: ${tripId})ã€‚è«‹ç¢ºèªæ˜¯å¦å·²å»ºç«‹ã€‚`);
            }
          } catch (e) { 
            console.error(e);
            displayText(bubble, "é€£ç·šéŒ¯èª¤ï¼Œç„¡æ³•è®€å–è¡Œç¨‹ã€‚");
          }
        }

      sendBtn.addEventListener('click', () => { const t=input.value.trim(); input.value=''; sendMessage(t); });
      input.addEventListener('keypress', (e) => { if(e.key==='Enter'){ const t=input.value.trim(); input.value=''; sendMessage(t); } });

      // å•Ÿå‹•
      document.addEventListener('DOMContentLoaded', initChat);
    </script>
  </body>
  </html>
